Traceback (most recent call last):
  File "/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/jupyter_core/utils/__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/jupyter_core/utils/__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
  File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/asyncio/base_events.py", line 649, in run_until_complete
    return future.result()
  File "/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from sklearn.neighbors import KNeighborsClassifier, BallTree
from matplotlib.patches import Rectangle, Circle
from IPython.display import HTML
import warnings
warnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning)

# Sample dataset: 2D, 2 classes
np.random.seed(42)
X_train = np.array([[1, 2], [2, 3], [3, 4], [6, 5], [7, 7], [1, 4], [2, 5]])
y_train = np.array([0, 0, 0, 1, 1, 0, 1])
query_point = np.array([4, 4])
k = 3

# Colors and styles
class_colors = {0: 'blue', 1: 'red'}
query_color = 'green'
neighbor_color = 'yellow'

# --- Brute-force k-NN Animation ---
def animate_brute_force():
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.set_xlim(0, 8)
    ax.set_ylim(0, 8)
    ax.set_xlabel('Feature 1')
    ax.set_ylabel('Feature 2')
    ax.set_title('Brute-force k-NN (k=3)')
    
    # Plot training points
    for x, y in zip(X_train, y_train):
        ax.scatter(x[0], x[1], c=class_colors[y], s=100, label='Class 0' if y == 0 else 'Class 1')
    ax.scatter(query_point[0], query_point[1], c=query_color, s=150, marker='*', label='Query')
    
    # Calculate distances
    distances = [np.sqrt(np.sum((query_point - x) ** 2)) for x in X_train]
    sorted_indices = np.argsort(distances)[:k]
    
    lines = []
    texts = []
    
    def init():
        ax.legend()
        return []
    
    def update(frame):
        ax.clear()
        ax.set_xlim(0, 8)
        ax.set_ylim(0, 8)
        ax.set_xlabel('Feature 1')
        ax.set_ylabel('Feature 2')
        ax.set_title('Brute-force k-NN (k=3)')
        
        # Plot all points
        for x, y in zip(X_train, y_train):
            ax.scatter(x[0], x[1], c=class_colors[y], s=100)
        ax.scatter(query_point[0], query_point[1], c=query_color, s=150, marker='*')
        
        # Draw distance lines up to current frame
        for i in range(min(frame + 1, len(X_train))):
            x1, y1 = query_point
            x2, y2 = X_train[i]
            line = ax.plot([x1, x2], [y1, y2], 'k--', alpha=0.5)[0]
            lines.append(line)
            dist = distances[i]
            text = ax.text((x1 + x2) / 2, (y1 + y2) / 2, f'{dist:.2f}', fontsize=8)
            texts.append(text)
        
        # Highlight k nearest neighbors
        if frame >= len(X_train):
            for i in sorted_indices:
                ax.scatter(X_train[i][0], X_train[i][1], c=neighbor_color, s=150, alpha=0.5)
            
        return lines + texts
    
    ani = FuncAnimation(fig, update, frames=len(X_train) + 2, init_func=init, blit=False, interval=500)
    plt.close()  # Prevent static plot display
    return HTML(ani.to_html5_video())

# --- KD-Tree k-NN Animation ---
class KDNode:
    def __init__(self, point, label, axis, left=None, right=None):
        self.point = point
        self.label = label
        self.axis = axis
        self.left = left
        self.right = right

class KDTree:
    def build(self, X, y, depth=0):
        if len(X) == 0:
            return None
        if len(X) == 1:
            return KDNode(X[0], y[0], depth % 2)
        
        axis = depth % 2
        indices = np.argsort(X[:, axis])
        X = X[indices]
        y = y[indices]
        median_idx = len(X) // 2
        
        node = KDNode(X[median_idx], y[median_idx], axis)
        node.left = self.build(X[:median_idx], y[:median_idx], depth + 1)
        node.right = self.build(X[median_idx + 1:], y[median_idx + 1:], depth + 1)
        return node

def animate_kd_tree():
    kdtree = KDTree()
    root = kdtree.build(X_train, y_train)
    
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.set_xlim(0, 8)
    ax.set_ylim(0, 8)
    ax.set_xlabel('Feature 1')
    ax.set_ylabel('Feature 2')
    ax.set_title('KD-Tree k-NN (k=3)')
    
    splits = []
    def collect_splits(node, bounds):
        if node is None:
            return
        x_min, x_max, y_min, y_max = bounds
        if node.axis == 0:
            splits.append(('x', node.point[0], y_min, y_max))
        else:
            splits.append(('y', node.point[1], x_min, x_max))
        collect_splits(node.left, (x_min, node.point[node.axis], y_min, y_max) if node.axis == 0 else (x_min, x_max, y_min, node.point[node.axis]))
        collect_splits(node.right, (node.point[node.axis], x_max, y_min, y_max) if node.axis == 0 else (x_min, x_max, node.point[node.axis], y_max))
    
    collect_splits(root, (0, 8, 0, 8))
    
    # Simulate search path (simplified)
    search_path = []
    def search(node, point, bounds):
        if node is None:
            return
        search_path.append((node, bounds))
        axis = node.axis
        if point[axis] <= node.point[axis]:
            close = node.left
            far = node.right
            close_bounds = (bounds[0], node.point[axis], bounds[2], bounds[3]) if axis == 0 else (bounds[0], bounds[1], bounds[2], node.point[axis])
            far_bounds = (node.point[axis], bounds[1], bounds[2], bounds[3]) if axis == 0 else (bounds[0], bounds[1], node.point[axis], bounds[3])
        else:
            close = node.right
            far = node.left
            close_bounds = (node.point[axis], bounds[1], bounds[2], bounds[3]) if axis == 0 else (bounds[0], bounds[1], node.point[axis], bounds[3])
            far_bounds = (bounds[0], node.point[axis], bounds[2], bounds[3]) if axis == 0 else (bounds[0], bounds[1], bounds[2], node.point[axis])
        search(node.left if point[axis] <= node.point[axis] else node.right, point, close_bounds)
    
    search(root, query_point, (0, 8, 0, 8))
    
    # Use scikit-learn for accurate neighbors
    knn = KNeighborsClassifier(n_neighbors=k, algorithm='kd_tree')
    knn.fit(X_train, y_train)
    neighbors = knn.kneighbors([query_point], return_distance=False)[0]
    
    def init():
        ax.scatter(X_train[:, 0], X_train[:, 1], c=[class_colors[y] for y in y_train], s=100)
        ax.scatter(query_point[0], query_point[1], c=query_color, s=150, marker='*')
        ax.legend(['Class 0', 'Class 1', 'Query'])
        return []
    
    def update(frame):
        ax.clear()
        ax.set_xlim(0, 8)
        ax.set_ylim(0, 8)
        ax.set_xlabel('Feature 1')
        ax.set_ylabel('Feature 2')
        ax.set_title('KD-Tree k-NN (k=3)')
        
        # Plot points
        ax.scatter(X_train[:, 0], X_train[:, 1], c=[class_colors[y] for y in y_train], s=100)
        ax.scatter(query_point[0], query_point[1], c=query_color, s=150, marker='*')
        
        # Draw splits
        for i in range(min(frame + 1, len(splits))):
            split_type, value, min_bound, max_bound = splits[i]
            if split_type == 'x':
                ax.axvline(value, ymin=min_bound/8, ymax=max_bound/8, color='black', linestyle='--')
            else:
                ax.axhline(value, xmin=min_bound/8, xmax=max_bound/8, color='black', linestyle='--')
        
        # Highlight search path
        if frame >= len(splits):
            for i in range(min(frame - len(splits) + 1, len(search_path))):
                node, bounds = search_path[i]
                x_min, x_max, y_min, y_max = bounds
                rect = Rectangle((x_min, y_min), x_max - x_min, y_max - y_min, fill=False, edgecolor='purple', linewidth=2)
                ax.add_patch(rect)
        
        # Highlight neighbors
        if frame >= len(splits) + len(search_path):
            for i in neighbors:
                ax.scatter(X_train[i][0], X_train[i][1], c=neighbor_color, s=150, alpha=0.5)
        
        return []
    
    ani = FuncAnimation(fig, update, frames=len(splits) + len(search_path) + 2, init_func=init, blit=False, interval=1000)
    plt.close()
    return HTML(ani.to_html5_video())

# --- Ball Tree k-NN Animation ---
def animate_ball_tree():
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.set_xlim(0, 8)
    ax.set_ylim(0, 8)
    ax.set_xlabel('Feature 1')
    ax.set_ylabel('Feature 2')
    ax.set_title('Ball Tree k-NN (k=3)')
    
    # Build Ball Tree with scikit-learn
    ball_tree = BallTree(X_train, leaf_size=2)
    _, neighbors = ball_tree.query([query_point], k=k)
    neighbors = neighbors[0]
    
    # Simulate ball construction (simplified)
    balls = []
    def simulate_balls(X, depth=0):
        if len(X) <= 2:
            return
        centroid = np.mean(X, axis=0)
        radius = np.max([np.sqrt(np.sum((x - centroid) ** 2)) for x in X])
        balls.append((centroid, radius))
        indices = np.argsort([np.sqrt(np.sum((x - centroid) ** 2)) for x in X])
        X = X[indices]
        mid = len(X) // 2
        simulate_balls(X[:mid], depth + 1)
        simulate_balls(X[mid:], depth + 1)
    
    simulate_balls(X_train)
    
    def init():
        ax.scatter(X_train[:, 0], X_train[:, 1], c=[class_colors[y] for y in y_train], s=100)
        ax.scatter(query_point[0], query_point[1], c=query_color, s=150, marker='*')
        ax.legend(['Class 0', 'Class 1', 'Query'])
        return []
    
    def update(frame):
        ax.clear()
        ax.set_xlim(0, 8)
        ax.set_ylim(0, 8)
        ax.set_xlabel('Feature 1')
        ax.set_ylabel('Feature 2')
        ax.set_title('Ball Tree k-NN (k=3)')
        
        # Plot points
        ax.scatter(X_train[:, 0], X_train[:, 1], c=[class_colors[y] for y in y_train], s=100)
        ax.scatter(query_point[0], query_point[1], c=query_color, s=150, marker='*')
        
        # Draw balls
        for i in range(min(frame + 1, len(balls))):
            centroid, radius = balls[i]
            circle = Circle(centroid, radius, fill=False, edgecolor='black', linestyle='--')
            ax.add_patch(circle)
        
        # Highlight neighbors
        if frame >= len(balls):
            for i in neighbors:
                ax.scatter(X_train[i][0], X_train[i][1], c=neighbor_color, s=150, alpha=0.5)
        
        return []
    
    ani = FuncAnimation(fig, update, frames=len(balls) + 2, init_func=init, blit=False, interval=1000)
    plt.close()
    return HTML(ani.to_html5_video())

# Display animations in Jupyter
print("Brute-force k-NN Animation:")
display(animate_brute_force())

print("KD-Tree k-NN Animation:")
display(animate_kd_tree())

print("Ball Tree k-NN Animation:")
display(animate_ball_tree())
------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mAttributeError[0m                            Traceback (most recent call last)
Cell [0;32mIn[1], line 8[0m
[1;32m      6[0m [38;5;28;01mfrom[39;00m[38;5;250m [39m[38;5;21;01mIPython[39;00m[38;5;21;01m.[39;00m[38;5;21;01mdisplay[39;00m[38;5;250m [39m[38;5;28;01mimport[39;00m HTML
[1;32m      7[0m [38;5;28;01mimport[39;00m[38;5;250m [39m[38;5;21;01mwarnings[39;00m
[0;32m----> 8[0m warnings[38;5;241m.[39mfilterwarnings([38;5;124m"[39m[38;5;124mignore[39m[38;5;124m"[39m, category[38;5;241m=[39m[43mnp[49m[38;5;241;43m.[39;49m[43mVisibleDeprecationWarning[49m)
[1;32m     10[0m [38;5;66;03m# Sample dataset: 2D, 2 classes[39;00m
[1;32m     11[0m np[38;5;241m.[39mrandom[38;5;241m.[39mseed([38;5;241m42[39m)

File [0;32m/Volumes/MacSSD/Machine Learning for Business/.venv/lib/python3.10/site-packages/numpy/__init__.py:414[0m, in [0;36m__getattr__[0;34m(attr)[0m
[1;32m    411[0m     [38;5;28;01mimport[39;00m[38;5;250m [39m[38;5;21;01mnumpy[39;00m[38;5;21;01m.[39;00m[38;5;21;01mchar[39;00m[38;5;250m [39m[38;5;28;01mas[39;00m[38;5;250m [39m[38;5;21;01mchar[39;00m
[1;32m    412[0m     [38;5;28;01mreturn[39;00m char[38;5;241m.[39mchararray
[0;32m--> 414[0m [38;5;28;01mraise[39;00m [38;5;167;01mAttributeError[39;00m([38;5;124m"[39m[38;5;124mmodule [39m[38;5;132;01m{!r}[39;00m[38;5;124m has no attribute [39m[38;5;124m"[39m
[1;32m    415[0m                      [38;5;124m"[39m[38;5;132;01m{!r}[39;00m[38;5;124m"[39m[38;5;241m.[39mformat([38;5;18m__name__[39m, attr))

[0;31mAttributeError[0m: module 'numpy' has no attribute 'VisibleDeprecationWarning'

